<%#
  NHL — Schedule partial
  Renders upcoming and recent games for the selected team set.
  Nil-safe: coalesces inputs to Arrays; will not crash on `.any?`.
%>

<%
  # ---------- Coalesce locals ----------
  games          = (defined?(games) && games) || (defined?(schedule) && schedule) || []
  games          = Array(games)
  teams          = Array(defined?(teams) ? teams : nil)
  preferred_team = defined?(preferred_team) ? preferred_team : nil

  # Accept pre-partitioned arrays if passed; otherwise derive from `games`
  upcoming       = Array(defined?(upcoming_games) ? upcoming_games : nil)
  recent         = Array(defined?(recent_games)   ? recent_games   : nil)

  now_utc        = defined?(now_utc) ? now_utc : Time.now.utc
  start_date     = defined?(start_date) ? start_date : nil
  end_date       = defined?(end_date)   ? end_date   : nil

  # ---------- Helpers ----------
  def tz_time(date_str)
    Time.parse(date_str.to_s)
  rescue
    Time.at(0)
  end

  def fmt_time_local(date_str)
    t = tz_time(date_str)
    t.getlocal.strftime("%a %b %-d, %-I:%M %p")
  end

  def final_status?(s)
    x = s.to_s.upcase
    x.include?("FINAL") || x.include?("GAME OVER") || x == "OFF"
  end

  # If upcoming/recent not provided, derive from `games`
  if upcoming.empty? && recent.empty? && games.any?
    tmp_up = []
    tmp_re = []
    games.each do |g|
      sg = g.is_a?(Hash) ? g.transform_keys { |k| k.respond_to?(:to_sym) ? k.to_sym : k } : g
      date_s = sg[:date] || sg["date"]
      status = sg[:status] || sg["status"]
      live   = sg[:live] || sg["live"]
      t_utc  = tz_time(date_s).utc

      if live
        tmp_up << sg
      elsif final_status?(status) || t_utc < now_utc
        tmp_re << sg
      else
        tmp_up << sg
      end
    end

    # Sort upcoming chronologically, recent reverse-chronologically
    upcoming = tmp_up.sort_by { |x| tz_time(x[:date] || x["date"]) }
    recent   = tmp_re.sort_by { |x| tz_time(x[:date] || x["date"]) }.reverse
  end

  # Limit lengths if you want a compact UI (optional)
  # upcoming = upcoming.first(6)
  # recent   = recent.first(6)

  # Helper to render one game row
  def render_row(g, preferred_team)
    sg   = g.is_a?(Hash) ? g.transform_keys { |k| k.respond_to?(:to_sym) ? k.to_sym : k } : g
    home = sg[:home] || {}
    away = sg[:away] || {}
    live = sg[:live] ? "LIVE" : nil
    status = (sg[:status] || "").to_s
    dt   = fmt_time_local(sg[:date])

    # Highlight preferred team (bold) if present on either side
    def team_text(side, preferred_team)
      abbr  = side[:abbr] || side["abbr"]
      score = side[:score] || side["score"]
      name  = abbr || (side[:name] || side["name"] || "")
      text  = [name, (score.nil? ? nil : score)].compact.join(" ")
      if preferred_team && abbr.to_s.upcase == preferred_team.to_s.upcase
        "<strong>#{Rack::Utils.escape_html(text)}</strong>"
      else
        Rack::Utils.escape_html(text)
      end
    end

    left  = team_text(away, preferred_team)
    right = team_text(home, preferred_team)

    badge =
      if live
        '<span class="badge live">LIVE</span>'
      elsif final_status?(status)
        '<span class="badge final">FINAL</span>'
      else
        "<span class=\"badge time\">#{Rack::Utils.escape_html(dt)}</span>"
      end

    <<~HTML
      <div class="row">
        <div class="teams">
          <span class="team away">#{left}</span>
          <span class="sep">@</span>
          <span class="team home">#{right}</span>
        </div>
        <div class="meta">#{badge}</div>
      </div>
    HTML
  end
%>

<style>
  .sched { display: grid; grid-template-columns: 1fr; gap: 10px; }
  .sched .block { border: 1px solid #eee; padding: 8px; border-radius: 6px; }
  .sched h4 { margin: 0 0 6px 0; font-size: 13px; color: #333; }
  .row { display: flex; align-items: center; justify-content: space-between; padding: 4px 0; border-bottom: 1px dashed #eee; }
  .row:last-child { border-bottom: 0; }
  .teams { display: flex; gap: 6px; align-items: baseline; }
  .team { font-size: 13px; }
  .sep { color: #888; font-size: 12px; }
  .meta { font-size: 11px; color: #555; }
  .badge { padding: 1px 6px; border-radius: 10px; font-weight: 600; font-size: 10px; border: 1px solid #ddd; }
  .badge.live  { color: #b30000; border-color: #f3c0c0; }
  .badge.final { color: #0a5; border-color: #cfeee2; }
  .badge.time  { color: #333; border-color: #ddd; }
  .empty { color: #777; font-size: 12px; }
  .note { color: #888; font-size: 11px; margin-top: 6px; }
</style>

<div class="sched">
  <% if upcoming.any? %>
    <div class="block">
      <h4>Upcoming</h4>
      <% upcoming.each do |g| %>
        <%= render_row(g, preferred_team) %>
      <% end %>
    </div>
  <% end %>

  <% if recent.any? %>
    <div class="block">
      <h4>Recent</h4>
      <% recent.each do |g| %>
        <%= render_row(g, preferred_team) %>
      <% end %>
    </div>
  <% end %>

  <% if !upcoming.any? && !recent.any? %>
    <div class="empty">
      No games for
      <strong><%= (teams.any? ? teams.join(", ") : (preferred_team || "your teams")) %></strong>
      <% if start_date && end_date %>
        between <%= start_date %> and <%= end_date %>.
      <% else %>
        in the selected window.
      <% end %>
    </div>
  <% end %>

  <div class="note">
    Showing only selected teams: <%= (teams.any? ? teams.join(", ") : preferred_team || "—") %>
  </div>
</div>