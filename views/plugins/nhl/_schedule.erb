<%#
  NHL â€” Schedule partial
  Shows upcoming and recent (limited to 2 by the Ruby side).
  If there is no game within 5 days, shows a "Next game is ..." fallback,
  or "No upcoming scheduled games found for the next 30 days."
  Nil-safe: coalesces inputs to Arrays; will not crash on `.any?`.
%>

<%
  # ---------- Coalesce locals ----------
  games          = (defined?(games) && games) || (defined?(schedule) && schedule) || []
  games          = Array(games)
  teams          = Array(defined?(teams) ? teams : nil)
  preferred_team = defined?(preferred_team) ? preferred_team : nil

  # Accept pre-partitioned arrays if passed; otherwise derive from `games`
  upcoming       = Array(defined?(upcoming_games) ? upcoming_games : nil)
  recent         = Array(defined?(recent_games)   ? recent_games   : nil)

  # Fallback/logic inputs
  now_utc        = defined?(now_utc) ? now_utc : Time.now.utc
  start_date     = defined?(start_date) ? start_date : nil
  end_date       = defined?(end_date)   ? end_date   : nil
  next_game      = defined?(next_game)  ? next_game  : nil

  # ---------- Helpers ----------
  def tz_time(date_str)
    Time.parse(date_str.to_s)
  rescue
    Time.at(0)
  end

  def fmt_time_local(date_str)
    t = tz_time(date_str)
    t.getlocal.strftime("%a %b %-d, %-I:%M %p")
  end

  def final_status?(s)
    x = s.to_s.upcase
    x.include?("FINAL") || x.include?("GAME OVER") || x == "OFF"
  end

  # If upcoming/recent not provided, derive from `games`
  if upcoming.empty? && recent.empty? && games.any?
    tmp_up = []
    tmp_re = []
    games.each do |g|
      sg = g.is_a?(Hash) ? g.transform_keys { |k| k.respond_to?(:to_sym) ? k.to_sym : k } : g
      date_s = sg[:date] || sg["date"]
      status = sg[:status] || sg["status"]
      live   = sg[:live] || sg["live"]
      t_utc  = tz_time(date_s).utc

      if live
        tmp_up << sg
      elsif final_status?(status) || t_utc < now_utc
        tmp_re << sg
      else
        tmp_up << sg
      end
    end

    # Sort upcoming chronologically, recent reverse-chronologically
    upcoming = tmp_up.sort_by { |x| tz_time(x[:date] || x["date"]) }
    recent   = tmp_re.sort_by { |x| tz_time(x[:date] || x["date"]) }.reverse
  end
%>

<style>
  .sched { display: grid; grid-template-columns: 1fr; gap: 10px; }
  .sched .block { border: 1px solid #eee; padding: 8px; border-radius: 6px; }
  .sched h4 { margin: 0 0 6px 0; font-size: 13px; color: #333; }
  .row { display: flex; align-items: center; justify-content: space-between; padding: 4px 0; border-bottom: 1px dashed #eee; }
  .row:last-child { border-bottom: 0; }
  .teams { display: flex; gap: 6px; align-items: baseline; }
  .team { font-size: 13px; }
  .sep { color: #888; font-size: 12px; }
  .meta { font-size: 11px; color: #555; }
